
Representational state transfer   is the  software architecture used for web services. RESTful web services provides  computer systems and internet work together.
According to rest api clients and servers are separated from each other. Server doesnt keep any information about the client so its stateless.
They have uniform interface and are loosely coupled, like the way we want in microservices. They have a layered system.They can also extend the functionality of client temporarly on demand.
A RESTful web application provides information about its resources. Resources are identified with the help of URLs.

But what is the best serialization technology and how are we going to decide.
If we have already started with  protocol buffers we should go on with that . Or if we are using json we should go on with that.
Avro should be used if we are dealing with big data.

Facebook, Cassandra project  Apache Thrift
Google,  ActiveMQ Protocol Buffers
Avro Apache Hadoop
Protocol Buffers have a better documentation when compared with Apache Thrift. Protocol Buffers are slightly faster. 
Avro does not require that code be generated. Data is always accompanied by a schema that permits full processing of that data without
code generation, static datatypes, etc.
In Avro serialisation and deserialization can be done without code generation. Also code generation is also available for statically typed languages such as java 




There is a Benchmarking for thrift-protobuf-Avro and you get get the document from [Benchmark](https://code.google.com/archive/p/thrift-protobuf-compare/wikis/BenchmarkingV2.wiki)

<p align="center">
  <img  src="https://chart.apis.google.com/chart?chtt=total&chf=c||lg||0||FFFFFF||1||76A4FB||0|bg||s||EFEFEF&chs=700x390&chd=t:3396,3477,3606,3714,3821,4418,4472,5173,5433,6344,6640,6817,7034,7094,7342,7481,7717,8002,8138,9170,9590,11892,12268,13005,19082,20038,22436,23467,26402,27639,31339,32480,41521,42950,44923,63267,75261,112497,140017,173274&chds=0,190602.35259999998&chxt=y&chxl=0:|json%2Fgoogle-gson|json%2Fprotobuf|scala%2Fjava-built-in|java-built-in|xml%2Fxstream%2Bc|bson%2Fmongodb|xml%2Fxstream%2Bc-fastinfo|xml%2Fxstream%2Bc-woodstox|xml%2Fxstream%2Bc-aalto|xml%2Fmanual-fastinfo|xml%2Fjavolution|bson%2Fjackson-databind|hessian|bson%2Fjackson-manual|xml%2Fjackson-databind%2Faalto|xml%2Fmanual-woodstox|avro-generic|avro|xml%2Fmanual-aalto|json%2Fjackson-databind|json%2Fprotostuff-runtime|smile%2Fjackson-databind|smile%2Fprotostuff-runtime|json%2Fprotostuff-manual|scala%2Fsbinary|json%2Fjackson-manual|thrift|protobuf%2Factivemq%2Balt|thrift-compact|protobuf|smile%2Fprotostuff-manual|smile%2Fjackson-manual|kryo|kryo-opt|protostuff-runtime|kryo-manual|protobuf%2Fprotostuff|protostuff|protostuff-manual|java-manual&chm=N%20*f*,000000,0,-1,10&lklk&chdlp=t&chco=660000|660033|660066|660099|6600CC|6600FF|663300|663333|663366|663399|6633CC|6633FF|666600|666633|666666&cht=bhg&chbh=5,0,4&nonsense=aaa.png%27">
  
</p>



Total Time 
Create an object, serialize it to a byte array, then deserialize it back to an object.



Serialization Time 
Create an object, serialize it to a byte array. * Java's built-in serializer faithfully represents arbitrary object graphs, which hurts performance.

Deserialization Time 
Often the most expensive operation. To make a fair comparison, all fields of the deserialized instances are accessed - this forces lazy deserializers to really do their work. The raw data below shows additional measurements for deserialization.



https://code.google.com/p/thrift-protobuf-compare/wiki/BenchmarkingV2
